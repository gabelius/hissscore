<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Snake Game</title>
  <style>
    /* Basic reset and styling */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #222;
      font-family: Arial, sans-serif;
      color: #fff;
      touch-action: none; /* Prevent default touch behaviors */
    }
    #gameOverlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <!-- UI Overlay -->
  <div id="gameOverlay">
    <div>Score: <span id="score">0</span></div>
    <div>Snake Length: <span id="snakeLength">1</span></div>
    <div>Status: <span id="gameStatus">Running</span></div>
    <div style="font-size: 12px; margin-top: 5px;">
      Controls: Use arrow keys or WASD for horizontal movement, Q/E for vertical movement.<br>
      On mobile, swipe horizontally to change direction and swipe vertically to change floors.
    </div>
  </div>

  <!-- Load PixiJS from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.2/browser/pixi.min.js"></script>
  <script>
    /***********************************************
     * 3D Snake Game Implementation using PixiJS  *
     ***********************************************/

    // Game configuration constants
    const GRID_SIZE = 20;
    const GAME_WIDTH = 600;
    const GAME_HEIGHT = 600;
    const FLOOR_COUNT = 3;
    // Projection offsets per floor level (simulate 30Â° top-down view)
    const FLOOR_OFFSET_X = 20; // horizontal shift per floor
    const FLOOR_OFFSET_Y = 10; // vertical shift per floor

    // Create the PixiJS application
    const app = new PIXI.Application({
      width: GAME_WIDTH,
      height: GAME_HEIGHT,
      backgroundColor: 0x222222,
    });
    document.body.appendChild(app.view);

    // Main container for game objects
    const gameContainer = new PIXI.Container();
    app.stage.addChild(gameContainer);

    /********************
     * Helper Functions *
     ********************/

    // Simple oblique projection for (x, y, z) -> screen coordinate.
    function project3D(x, y, z) {
      const screenX = x + z * FLOOR_OFFSET_X;
      const screenY = y - z * FLOOR_OFFSET_Y;
      return { x: screenX, y: screenY };
    }

    /********************
     * Draw the Floors  *
     ********************/
    function createFloor(z, color) {
      const floor = new PIXI.Graphics();
      floor.beginFill(color);
      floor.drawRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      floor.endFill();
      // Position floor based on its z-level projection
      const pos = project3D(0, 0, z);
      floor.x = pos.x;
      floor.y = pos.y;
      // Use transparency so game objects above remain visible
      floor.alpha = 0.1;
      return floor;
    }
    const floorColors = [0x555555, 0x666666, 0x777777];
    for (let z = 0; z < FLOOR_COUNT; z++) {
      const floor = createFloor(z, floorColors[z]);
      // Add floors at the bottom of the display list so they appear behind snake and food
      gameContainer.addChildAt(floor, 0);
    }

    /********************
     * Game State Setup *
     ********************/
    // Snake object: starts at the center of the game area on floor 0.
    let snake = {
      segments: [
        {
          x: Math.floor(GAME_WIDTH / 2 / GRID_SIZE) * GRID_SIZE,
          y: Math.floor(GAME_HEIGHT / 2 / GRID_SIZE) * GRID_SIZE,
          z: 0
        }
      ],
      // Initial movement: moving right by GRID_SIZE pixels every move.
      direction: { x: GRID_SIZE, y: 0, z: 0 },
      pendingDirection: null, // buffer input changes to apply on next move
      speed: 200, // movement interval in milliseconds
      lastMoveTime: 0,
    };

    // Array to hold Pixi Graphics for each snake segment.
    let snakeSprites = [];
    function createSnakeSegmentSprite(segment) {
      const sprite = new PIXI.Graphics();
      sprite.beginFill(0x00ff00);
      sprite.drawRect(0, 0, GRID_SIZE, GRID_SIZE);
      sprite.endFill();
      gameContainer.addChild(sprite);
      return sprite;
    }
    function updateSnakeSprites() {
      // Ensure there is one sprite per snake segment.
      while (snakeSprites.length < snake.segments.length) {
        const sprite = createSnakeSegmentSprite(snake.segments[snakeSprites.length]);
        snakeSprites.push(sprite);
      }
      // Update sprite positions according to projected coordinates.
      snake.segments.forEach((seg, i) => {
        const pos = project3D(seg.x, seg.y, seg.z);
        snakeSprites[i].x = pos.x;
        snakeSprites[i].y = pos.y;
      });
      // Update UI snake length
      document.getElementById('snakeLength').textContent = snake.segments.length;
    }

    // Food object: will be spawned randomly.
    let food = { x: 0, y: 0, z: 0 };
    let foodSprite = new PIXI.Graphics();
    function spawnFood() {
      // Randomly choose one of the three floors.
      const z = Math.floor(Math.random() * FLOOR_COUNT);
      // Random x and y on the grid.
      const cols = GAME_WIDTH / GRID_SIZE;
      const rows = GAME_HEIGHT / GRID_SIZE;
      const x = Math.floor(Math.random() * cols) * GRID_SIZE;
      const y = Math.floor(Math.random() * rows) * GRID_SIZE;
      food = { x, y, z };
      // Draw the food as a red circle.
      foodSprite.clear();
      foodSprite.beginFill(0xff0000);
      foodSprite.drawCircle(0, 0, GRID_SIZE / 2);
      foodSprite.endFill();
      const pos = project3D(food.x, food.y, food.z);
      // Center the circle in the grid cell.
      foodSprite.x = pos.x + GRID_SIZE / 2;
      foodSprite.y = pos.y + GRID_SIZE / 2;
      if (!gameContainer.children.includes(foodSprite)) {
        gameContainer.addChild(foodSprite);
      }
    }
    spawnFood();

    // Score tracking
    let score = 0;
    const scoreDisplay = document.getElementById('score');
    const gameStatusDisplay = document.getElementById('gameStatus');

    /********************
     * Input Handling   *
     ********************/

    // Keyboard Controls
    window.addEventListener('keydown', (e) => {
      e.preventDefault(); // Prevent scrolling
      let newDirection = null;
      // Horizontal movement: arrow keys or WASD.
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
        newDirection = { x: 0, y: -GRID_SIZE, z: 0 };
      } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
        newDirection = { x: 0, y: GRID_SIZE, z: 0 };
      } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        newDirection = { x: -GRID_SIZE, y: 0, z: 0 };
      } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        newDirection = { x: GRID_SIZE, y: 0, z: 0 };
      }
      // Vertical movement: Q to go down a floor, E to go up a floor.
      else if (e.key === 'q' || e.key === 'Q') {
        newDirection = { x: 0, y: 0, z: -1 };
      } else if (e.key === 'e' || e.key === 'E') {
        newDirection = { x: 0, y: 0, z: 1 };
      }
      if (newDirection) {
        // For vertical movement, ensure we remain within floor bounds.
        if (newDirection.z !== 0) {
          const newFloor = snake.segments[0].z + newDirection.z;
          if (newFloor >= 0 && newFloor < FLOOR_COUNT) {
            snake.pendingDirection = newDirection;
          }
        } else {
          snake.pendingDirection = newDirection;
        }
      }
    });

    // Touch Controls for Mobile: simple swipe detection.
    let touchStartX = null, touchStartY = null;
    window.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    });
    window.addEventListener('touchmove', (e) => {
      // Prevent page scrolling on touch
      e.preventDefault();
    }, { passive: false });
    window.addEventListener('touchend', (e) => {
      if (touchStartX === null || touchStartY === null) return;
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const diffX = touchEndX - touchStartX;
      const diffY = touchEndY - touchStartY;
      // Determine swipe direction
      if (Math.abs(diffX) > Math.abs(diffY)) {
        // Horizontal swipe
        if (diffX > 0) {
          snake.pendingDirection = { x: GRID_SIZE, y: 0, z: 0 };
        } else {
          snake.pendingDirection = { x: -GRID_SIZE, y: 0, z: 0 };
        }
      } else {
        // Vertical swipe: up swipe to go up a floor, down swipe to go down.
        if (diffY < 0) {
          snake.pendingDirection = { x: 0, y: 0, z: 1 };
        } else {
          snake.pendingDirection = { x: 0, y: 0, z: -1 };
        }
      }
      touchStartX = null;
      touchStartY = null;
    });

    /********************
     * Game Loop        *
     ********************/

    // Main game ticker
    app.ticker.add((delta) => {
      const now = Date.now();
      if (now - snake.lastMoveTime > snake.speed) {
        moveSnake();
        snake.lastMoveTime = now;
      }
    });

    // Move the snake based on its current direction.
    function moveSnake() {
      // Update direction if a pending input exists.
      if (snake.pendingDirection) {
        // For horizontal moves, optionally add logic to prevent direct reversal.
        if (snake.pendingDirection.z === 0) {
          if (snake.segments.length > 1) {
            const nextPos = {
              x: snake.segments[0].x + snake.pendingDirection.x,
              y: snake.segments[0].y + snake.pendingDirection.y,
              z: snake.segments[0].z
            };
            // If nextPos equals the second segment, ignore reversal.
            if (!(nextPos.x === snake.segments[1].x && nextPos.y === snake.segments[1].y)) {
              snake.direction = snake.pendingDirection;
            }
          } else {
            snake.direction = snake.pendingDirection;
          }
        } else {
          // For vertical movement, verify floor bounds.
          const newFloor = snake.segments[0].z + snake.pendingDirection.z;
          if (newFloor >= 0 && newFloor < FLOOR_COUNT) {
            snake.direction = snake.pendingDirection;
          }
        }
        snake.pendingDirection = null;
      }

      // Create a new head based on current direction.
      let newHead = {
        x: snake.segments[0].x,
        y: snake.segments[0].y,
        z: snake.segments[0].z
      };
      if (snake.direction.z !== 0) {
        // Vertical move: adjust floor only.
        newHead.z += snake.direction.z;
      } else {
        newHead.x += snake.direction.x;
        newHead.y += snake.direction.y;
      }

      // Wrap around horizontally.
      if (newHead.x < 0) newHead.x = GAME_WIDTH - GRID_SIZE;
      if (newHead.x >= GAME_WIDTH) newHead.x = 0;
      if (newHead.y < 0) newHead.y = GAME_HEIGHT - GRID_SIZE;
      if (newHead.y >= GAME_HEIGHT) newHead.y = 0;

      // Self-collision is allowed (the snake slides over itself) so we do not end the game.
      // In a more advanced version, collisions beyond a certain tolerance might trigger game over.

      // Add the new head at the front of the snake.
      snake.segments.unshift(newHead);

      // Check for food collision: if the snake's head is at the same grid and floor.
      if (newHead.x === food.x && newHead.y === food.y && newHead.z === food.z) {
        score += 10;
        document.getElementById('score').textContent = score;
        spawnFood();
      } else {
        // Remove the tail segment if no food is eaten.
        snake.segments.pop();
      }

      updateSnakeSprites();
    }

    // Initial sprite update
    updateSnakeSprites();

  </script>
</body>
</html>