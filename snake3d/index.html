<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Snake Garden</title>
  <style>
    /* Reset and basic styling */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #222;
      font-family: Arial, sans-serif;
      color: #fff;
      touch-action: none; /* Disable default touch actions */
    }
    #gameOverlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- UI Overlay -->
  <div id="gameOverlay">
    <div>Score: <span id="score">0</span></div>
    <div>Snake Length: <span id="snakeLength">1</span></div>
    <div>Status: <span id="gameStatus">Running</span></div>
    <div style="font-size: 12px; margin-top: 5px;">
      Controls:<br>
      Keyboard: Use arrow keys or WASD to move, Q/E for vertical moves.<br>
      Touch: Swipe horizontally to change direction and vertically to move between levels.
    </div>
  </div>

  <!-- Load PixiJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.2/browser/pixi.min.js"></script>
  <script>
    /*********************************************
     * 3D Snake Garden Game - Cylindrical Snake  *
     *********************************************/

    // Game configuration
    const GRID_SIZE = 20;
    const GAME_WIDTH = 600;
    const GAME_HEIGHT = 600;
    const FLOOR_COUNT = 3; // 0: ground, 1: elevated, 2: highest

    // Offsets to simulate a 30Â° top-down projection effect
    const FLOOR_OFFSET_X = 20;
    const FLOOR_OFFSET_Y = 10;

    // Create the PixiJS application
    const app = new PIXI.Application({
      width: GAME_WIDTH,
      height: GAME_HEIGHT,
      backgroundColor: 0x222222,
    });
    document.body.appendChild(app.view);

    // Main container for all game elements
    const gameContainer = new PIXI.Container();
    app.stage.addChild(gameContainer);

    // Projection function: maps (x,y,z) to screen coordinates.
    function project3D(x, y, z) {
      return {
        x: x + z * FLOOR_OFFSET_X,
        y: y - z * FLOOR_OFFSET_Y
      };
    }

    /***********************
     * Garden Environment  *
     ***********************/
    // Ground Floor (floor 0): the main garden background with shrubs.
    const groundContainer = new PIXI.Container();
    const groundBG = new PIXI.Graphics();
    groundBG.beginFill(0x88cc88); // grass-green color
    groundBG.drawRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    groundBG.endFill();
    groundContainer.addChild(groundBG);

    // Function to draw a shrub (a simple filled circle)
    function drawShrub(x, y, radius) {
      const shrub = new PIXI.Graphics();
      shrub.beginFill(0x558855);
      shrub.drawCircle(0, 0, radius);
      shrub.endFill();
      shrub.x = x;
      shrub.y = y;
      groundContainer.addChild(shrub);
    }
    // Add a few shrubs at fixed positions
    drawShrub(100, 150, 10);
    drawShrub(300, 400, 12);
    drawShrub(500, 200, 8);
    drawShrub(250, 100, 10);
    drawShrub(450, 500, 12);

    // Position groundContainer using projection (z=0)
    const groundPos = project3D(0, 0, 0);
    groundContainer.x = groundPos.x;
    groundContainer.y = groundPos.y;
    gameContainer.addChild(groundContainer);

    // Elevated Area for Floor 1: a raised garden patch with a ladder.
    const elevated1Container = new PIXI.Container();
    const platform1 = new PIXI.Graphics();
    platform1.beginFill(0x77aa77);
    platform1.drawRect(100, 100, 200, 200);
    platform1.endFill();
    elevated1Container.addChild(platform1);
    // Draw a ladder at the left edge of platform1.
    const ladder1 = new PIXI.Graphics();
    ladder1.lineStyle(2, 0x654321);
    const ladderX = 100;
    const ladderY = 150;
    ladder1.moveTo(ladderX, ladderY);
    ladder1.lineTo(ladderX, ladderY + 100);
    for (let i = 0; i <= 4; i++) {
      ladder1.moveTo(ladderX, ladderY + i * 25);
      ladder1.lineTo(ladderX + 15, ladderY + i * 25);
    }
    elevated1Container.addChild(ladder1);
    // Position elevated1Container using projection (z=1)
    const elevated1Pos = project3D(0, 0, 1);
    elevated1Container.x = elevated1Pos.x;
    elevated1Container.y = elevated1Pos.y;
    gameContainer.addChild(elevated1Container);

    // Elevated Area for Floor 2: a higher patch with its ladder.
    const elevated2Container = new PIXI.Container();
    const platform2 = new PIXI.Graphics();
    platform2.beginFill(0x669966);
    platform2.drawRect(350, 350, 150, 150);
    platform2.endFill();
    elevated2Container.addChild(platform2);
    // Ladder for elevated2 at the right edge of the platform.
    const ladder2 = new PIXI.Graphics();
    ladder2.lineStyle(2, 0x654321);
    const ladder2X = 350 + 150;
    const ladder2Y = 370;
    ladder2.moveTo(ladder2X, ladder2Y);
    ladder2.lineTo(ladder2X, ladder2Y + 80);
    for (let i = 0; i <= 3; i++) {
      ladder2.moveTo(ladder2X, ladder2Y + i * 20);
      ladder2.lineTo(ladder2X - 15, ladder2Y + i * 20);
    }
    elevated2Container.addChild(ladder2);
    // Position elevated2Container using projection (z=2)
    const elevated2Pos = project3D(0, 0, 2);
    elevated2Container.x = elevated2Pos.x;
    elevated2Container.y = elevated2Pos.y;
    gameContainer.addChild(elevated2Container);

    /**********************
     * Game State & Snake *
     **********************/
    // The snake starts at the center of the play area on the ground floor.
    let snake = {
      segments: [{
        x: Math.floor(GAME_WIDTH / 2 / GRID_SIZE) * GRID_SIZE,
        y: Math.floor(GAME_HEIGHT / 2 / GRID_SIZE) * GRID_SIZE,
        z: 0
      }],
      direction: { x: GRID_SIZE, y: 0, z: 0 },
      pendingDirection: null,
      speed: 200, // milliseconds per move
      lastMoveTime: 0,
    };

    // Array to store PIXI.Graphics objects for snake segments (head at index 0).
    let snakeSprites = [];

    // Create the snake head sprite (cylindrical body with a hood)
    function createSnakeHeadSprite() {
      const gfx = new PIXI.Graphics();
      // Draw the cylindrical head (circle)
      gfx.beginFill(0x00aa00);
      gfx.drawCircle(0, 0, GRID_SIZE / 2);
      gfx.endFill();
      // Draw a hood as a triangle on top of the head.
      gfx.beginFill(0x007700);
      gfx.drawPolygon([
        -GRID_SIZE / 4, -GRID_SIZE / 2,
         GRID_SIZE / 4, -GRID_SIZE / 2,
         0, -GRID_SIZE
      ]);
      gfx.endFill();
      return gfx;
    }

    // Create a snake body segment sprite (simple cylindrical shape)
    function createSnakeBodySprite() {
      const gfx = new PIXI.Graphics();
      gfx.beginFill(0x00cc00);
      gfx.drawCircle(0, 0, (GRID_SIZE / 2) * 0.9);
      gfx.endFill();
      return gfx;
    }

    // Update snake sprites to match current snake segments.
    function updateSnakeSprites() {
      for (let i = 0; i < snake.segments.length; i++) {
        let sprite = snakeSprites[i];
        if (!sprite) {
          sprite = (i === 0) ? createSnakeHeadSprite() : createSnakeBodySprite();
          gameContainer.addChild(sprite);
          snakeSprites[i] = sprite;
        }
        const seg = snake.segments[i];
        const pos = project3D(seg.x, seg.y, seg.z);
        // Center the sprite within the grid cell.
        sprite.x = pos.x + GRID_SIZE / 2;
        sprite.y = pos.y + GRID_SIZE / 2;
      }
      // Remove any extra sprites.
      while (snakeSprites.length > snake.segments.length) {
        const extra = snakeSprites.pop();
        gameContainer.removeChild(extra);
      }
      document.getElementById('snakeLength').textContent = snake.segments.length;
    }

    /********************
     * Food Setup       *
     ********************/
    let food = { x: 0, y: 0, z: 0 };
    let foodSprite = new PIXI.Graphics();
    function spawnFood() {
      // Randomly choose one of the three floors.
      const z = Math.floor(Math.random() * FLOOR_COUNT);
      const cols = GAME_WIDTH / GRID_SIZE;
      const rows = GAME_HEIGHT / GRID_SIZE;
      const x = Math.floor(Math.random() * cols) * GRID_SIZE;
      const y = Math.floor(Math.random() * rows) * GRID_SIZE;
      food = { x, y, z };
      foodSprite.clear();
      foodSprite.beginFill(0xff0000);
      foodSprite.drawCircle(0, 0, GRID_SIZE / 2);
      foodSprite.endFill();
      const pos = project3D(food.x, food.y, food.z);
      foodSprite.x = pos.x + GRID_SIZE / 2;
      foodSprite.y = pos.y + GRID_SIZE / 2;
      if (!gameContainer.children.includes(foodSprite)) {
        gameContainer.addChild(foodSprite);
      }
    }
    spawnFood();

    let score = 0;
    document.getElementById('score').textContent = score;

    /********************
     * Input Handling   *
     ********************/
    window.addEventListener('keydown', (e) => {
      e.preventDefault(); // Prevent scrolling
      let newDir = null;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
        newDir = { x: 0, y: -GRID_SIZE, z: 0 };
      } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
        newDir = { x: 0, y: GRID_SIZE, z: 0 };
      } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        newDir = { x: -GRID_SIZE, y: 0, z: 0 };
      } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        newDir = { x: GRID_SIZE, y: 0, z: 0 };
      } else if (e.key === 'q' || e.key === 'Q') {
        newDir = { x: 0, y: 0, z: -1 };
      } else if (e.key === 'e' || e.key === 'E') {
        newDir = { x: 0, y: 0, z: 1 };
      }
      if (newDir) {
        // For vertical moves, ensure we remain within bounds.
        if (newDir.z !== 0) {
          const newFloor = snake.segments[0].z + newDir.z;
          if (newFloor >= 0 && newFloor < FLOOR_COUNT) {
            snake.pendingDirection = newDir;
          }
        } else {
          snake.pendingDirection = newDir;
        }
      }
    });

    // Touch Controls: detect swipe gestures.
    let touchStartX = null, touchStartY = null;
    window.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    });
    window.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });
    window.addEventListener('touchend', (e) => {
      if (touchStartX === null || touchStartY === null) return;
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const diffX = touchEndX - touchStartX;
      const diffY = touchEndY - touchStartY;
      if (Math.abs(diffX) > Math.abs(diffY)) {
        // Horizontal swipe.
        snake.pendingDirection = diffX > 0 ? { x: GRID_SIZE, y: 0, z: 0 } : { x: -GRID_SIZE, y: 0, z: 0 };
      } else {
        // Vertical swipe.
        snake.pendingDirection = diffY < 0 ? { x: 0, y: -GRID_SIZE, z: 0 } : { x: 0, y: GRID_SIZE, z: 0 };
      }
      touchStartX = null;
      touchStartY = null;
    });

    /********************
     * Game Loop        *
     ********************/
    app.ticker.add(() => {
      const now = Date.now();
      if (now - snake.lastMoveTime > snake.speed) {
        moveSnake();
        snake.lastMoveTime = now;
      }
    });

    function moveSnake() {
      // Update direction if there is a pending input.
      if (snake.pendingDirection) {
        if (snake.pendingDirection.z !== 0) {
          const newFloor = snake.segments[0].z + snake.pendingDirection.z;
          if (newFloor >= 0 && newFloor < FLOOR_COUNT) {
            snake.direction = snake.pendingDirection;
          }
        } else {
          if (snake.segments.length > 1) {
            const nextPos = {
              x: snake.segments[0].x + snake.pendingDirection.x,
              y: snake.segments[0].y + snake.pendingDirection.y,
              z: snake.segments[0].z
            };
            // Prevent direct reversal on horizontal moves.
            if (!(nextPos.x === snake.segments[1].x && nextPos.y === snake.segments[1].y)) {
              snake.direction = snake.pendingDirection;
            }
          } else {
            snake.direction = snake.pendingDirection;
          }
        }
        snake.pendingDirection = null;
      }

      let newHead = { ...snake.segments[0] };
      if (snake.direction.z !== 0) {
        newHead.z += snake.direction.z;
      } else {
        newHead.x += snake.direction.x;
        newHead.y += snake.direction.y;
      }
      // Wrap around horizontally.
      if (newHead.x < 0) newHead.x = GAME_WIDTH - GRID_SIZE;
      if (newHead.x >= GAME_WIDTH) newHead.x = 0;
      if (newHead.y < 0) newHead.y = GAME_HEIGHT - GRID_SIZE;
      if (newHead.y >= GAME_HEIGHT) newHead.y = 0;

      snake.segments.unshift(newHead);
      // Food collision: if the head lands on the food.
      if (newHead.x === food.x && newHead.y === food.y && newHead.z === food.z) {
        score += 10;
        document.('score').textContent = score;
        spawnFood();getElementById
      } else {
        snake.segments.pop();
      }
      updateSnakeSprites();
    }

    // Initial sprite update.
    updateSnakeSprites();

  </script>
</body>
</html>